/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.test.cooperation;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.MutablePair;
import org.opentestsystem.shared.test.api.cooperation.CooperativeInteractiveUser;
import org.opentestsystem.shared.test.api.cooperation.Cue;
import org.opentestsystem.shared.test.api.cooperation.CueCallback;
import org.opentestsystem.shared.test.api.cooperation.CuePattern;
import org.opentestsystem.shared.test.api.cooperation.Stage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This implementation uses a naive synchronization scheme that may not scale
 * well to large stages.
 * 
 * @author temp_dmenes
 * 
 */
public class StageImpl
    extends ConcurrentHashMap<String, CooperativeInteractiveUser<?, ?>>
    implements Stage
{

  private static final long                                 serialVersionUID = 1L;
  private static final Logger                               _logger          = LoggerFactory.getLogger (StageImpl.class);
  private final List<Cue>                                   _retainedCues    = new ArrayList<Cue> ();
  private final List<MutablePair<CuePattern, Cue>>          _waitingPatterns = new LinkedList<> ();
  private final Set<ImmutablePair<CuePattern, Queue<Cue>>>  _listeningQueues = new HashSet<> ();
  private final Set<ImmutablePair<CuePattern, CueCallback>> _callbacks       = new HashSet<> ();

  @Override
  public synchronized void
      sayCue (Cue cue) {
    if (cue.isRetained ()) {
      _retainedCues.add (cue);
    }

    // Pump cue into waiting queues
    for (ImmutablePair<CuePattern, Queue<Cue>> pair_i : _listeningQueues) {
      if (pair_i.getLeft ().isMatch (cue)) {
        if (!pair_i.getRight ().offer (cue)) {
          _logger.warn ("Cue {} rejected by listening queue", cue.getTag ());
        }
      }
    }

    // Call callbacks in this thread.
    for (ImmutablePair<CuePattern, CueCallback> pair_i : _callbacks) {
      if (pair_i.getLeft ().isMatch (cue)) {
        try {
          pair_i.getRight ().onCue (cue);
        } catch (Throwable t) {
          _logger.error ("Error raised processing cue callbacks on cue {}", cue.getTag (), t);
        }
      }
    }

    // Find threads waiting on this cue
    boolean found = false;
    int i = 0;
    while (i < _waitingPatterns.size ()) {
      MutablePair<CuePattern, Cue> pr_i = _waitingPatterns.get (i);
      if (pr_i.getLeft ().isMatch (cue)) {
        pr_i.setRight (cue);
        _waitingPatterns.remove (i);
        found = true;
      }
      else {
        i++;
      }
    }

    // Give found threads a chance to run
    if (found) {
      notifyAll ();
    }
  }

  @Override
  public synchronized List<Cue>
      listenForCues (final CuePattern pattern) throws InterruptedException {
    List<Cue> ans = getCurrentCues (pattern);

    if (ans.size () == 0) {
      // Didn't find a retained cue that matches the pattern, so we wait for
      // one.
      final MutablePair<CuePattern, Cue> pr = new MutablePair<CuePattern, Cue> (pattern, null);
      _waitingPatterns.add (pr);
      while (pr.getRight () == null) {
        wait ();
      }
      ans.add (pr.getRight ());
    }
    return ans;
  }

  @Override
  public synchronized List<Cue>
      getCurrentCues (final CuePattern pattern) {
    return pattern.getMatches (_retainedCues);
  }

  @Override
  public synchronized void registerCueCallback (CuePattern pattern, CueCallback callback) {
    _callbacks.add (new ImmutablePair<> (pattern, callback));
  }

  @Override
  public synchronized void unregisterCueCallback (CuePattern pattern, CueCallback callback) {
    _callbacks.remove (new ImmutablePair<> (pattern, callback));
  }

  @Override
  public synchronized void forgetRetainedCues (CuePattern pattern) {
    for (int i = 0; i < _retainedCues.size ();) {
      if (pattern.isMatch (_retainedCues.get (i))) {
        _retainedCues.remove (i);
      }
      else {
        i++;
      }
    }
  }

  @Override
  public synchronized void registerListeningQueue (CuePattern pattern, Queue<Cue> queue) {
    _listeningQueues.add (new ImmutablePair<> (pattern, queue));
    for (Cue cue_i : _retainedCues) {
      if (pattern.isMatch (cue_i)) {
        if (!queue.offer (cue_i)) {
          _logger.warn ("Cue {} rejected by listening queue", cue_i.getTag ());
        }
      }
    }
  }

  @Override
  public synchronized void unregisterListeningQueue (CuePattern pattern, Queue<Cue> queue) {
    _listeningQueues.remove (new ImmutablePair<> (pattern, queue));
  }

}
