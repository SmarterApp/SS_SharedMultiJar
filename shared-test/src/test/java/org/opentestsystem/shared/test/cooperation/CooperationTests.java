/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.test.cooperation;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.List;

import javax.annotation.Resource;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.shared.test.LifecycleManagingTestRunner;
import org.opentestsystem.shared.test.api.cooperation.CooperativeInteractiveUser;
import org.opentestsystem.shared.test.api.cooperation.Cue;
import org.opentestsystem.shared.test.api.cooperation.CueCallback;
import org.opentestsystem.shared.test.api.cooperation.CuePattern;
import org.opentestsystem.shared.test.api.cooperation.Stage;
import org.opentestsysten.shared.test.userstory.AbstractFirstPersonUserStory;
import org.springframework.test.context.ContextConfiguration;

@RunWith (LifecycleManagingTestRunner.class)
@ContextConfiguration ("test-context.xml")
public class CooperationTests
{

  private static final String        MESSAGE        = "THIS IS A SECRET";

  @SuppressWarnings ("rawtypes")
  @Resource (name = "talker")
  private CooperativeInteractiveUser talker;

  @SuppressWarnings ("rawtypes")
  @Resource (name = "listener1")
  private CooperativeInteractiveUser listener1;

  @SuppressWarnings ("rawtypes")
  @Resource (name = "listener2")
  private CooperativeInteractiveUser listener2;
  
  @Resource (name = "stage")
  private Stage stage;

  private final ListenerStory        listenerStory1 = new ListenerStory ();
  private final ListenerStory        listenerStory2 = new ListenerStory ();
  
  private class TestCallback implements CueCallback {
    public String receivedMessage = null;

    @Override
    public void onCue (Cue cue) throws Throwable {
      receivedMessage = (String) cue.getData ();
    }
    
  }

  @SuppressWarnings ("unchecked")
  @Before
  public void setUp () {
    talker.setScript (new TalkerStory (MESSAGE));
    listener1.setScript (listenerStory1);
    listener2.setScript (listenerStory2);
  }
  
  @After
  public void tearDown() {
    stage.forgetRetainedCues ( new CuePattern() {

      @Override
      public boolean isMatch (Cue cue) {
        return true;
      }
      
    });
  }

  @Test
  public void simpleSignallingTest () throws InterruptedException {
    listener1.startScript ();
    talker.startScript ();
    listener1.join ();
    assertTrue ("Didn't take expected time", listenerStory1.latency > 900 && listenerStory1.latency < 1100);
    assertEquals ("Didn't deliver correct message", MESSAGE, listenerStory1.message);
  }
  
  @Test
  public void callbackTest () throws Throwable {
    CuePattern pattern = new RegexCuePattern("CUE");
    TestCallback callback = new TestCallback();
    stage.registerCueCallback (pattern, callback);
    talker.doScriptSynchronous ();
    assertNotNull( "Message not processed by callback", callback.receivedMessage );
  }

  @Test
  public void callbackRemovalTest () throws Throwable {
    CuePattern pattern = new RegexCuePattern("CUE");
    TestCallback callback = new TestCallback();
    stage.registerCueCallback (pattern, callback);
    stage.unregisterCueCallback (pattern, callback);
    talker.doScriptSynchronous ();
    assertNull( "Callback not removed", callback.receivedMessage );
  }

  @SuppressWarnings ("rawtypes")
  private class ListenerStory extends AbstractFirstPersonUserStory
  {

    public volatile String message = null;
    public volatile long   latency = 0;

    @SuppressWarnings ("unchecked")
    @Override
    public void run () throws Exception {
      long start = System.currentTimeMillis ();
      List<Cue> cues = I ().listenFor (new RegexCuePattern ("CUE"));
      assertEquals ("Wrong number of cues received", 1, cues.size ());
      latency = System.currentTimeMillis () - start;
      message = (String) cues.get(0).getData ();
    }

    @Override
    public String getScriptName () {
      return "Listener script";
    }

  }

  @SuppressWarnings ("rawtypes")
  private class TalkerStory extends AbstractFirstPersonUserStory
  {
    public final String message;

    public TalkerStory (String message) {
      this.message = message;
    }

    @Override
    public void run () throws Exception {
      Thread.sleep (1000);
      Cue cue = new Cue ("CUE", message, true);
      I ().say (cue);
    }

    @Override
    public String getScriptName () {
      return "Talker script";
    }
  }
}
