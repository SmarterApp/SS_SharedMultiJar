/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.test.jetty;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.webapp.Configuration;
import org.eclipse.jetty.webapp.WebAppClassLoader;
import org.eclipse.jetty.webapp.WebAppContext;
import org.opentestsystem.shared.test.webapplication.BaseWebApplication;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.web.context.WebApplicationContext;

/**
 * Class that deploys a web application in an in-process Jetty container for the
 * duration of this test.
 * 
 * There are two scenarios for which this class is intended. In one case, the
 * application deployed to the Jetty container is the application under test. In
 * this case, we will use this class to allow for testing of an application
 * without the complexity of deploying the application to another web server. In
 * the other case, we deploy to the web container a mock or stub version of a
 * service that is required by the application under test.
 * 
 * In most circumstances, regardless of which of these two scenarios you are
 * using, you will need to set the {@code descriptor} property with the URL of
 * the web.xml file that should be used for this application, and the
 * {@code contextPath} property with the appropriate context path.
 * 
 * The container is configured to provide a single HTTP connector, which will
 * listen on all available interfaces on the port number specified by the
 * {@link #setPort} method. Other means of connecting, including HTTPS
 * connections and mock (non-network) connections may be added in the future.
 * 
 * The HTTP connector by default will listen on all interfaces. You may specify
 * a particular interface for incoming connections by providing the
 * {@code interface} property. If you set this to {@code 127.0.0.1} for
 * in-process testing, you will improve performance somewhat by not involving
 * the actual network layer in communications.
 * 
 * We may have significantly different requirements when running code in this
 * container than we would when running the same code in a conventional
 * production web container. Three issues, in particular, we need to consider:
 * what level of classloader isolation do we want, how do we want the Spring
 * context of the application inside the container to relate to the Spring
 * context in which the container is created, and how does the file layout
 * differ from the file layout expected in a standard {@code .war} file.
 * 
 * <h2>Classloader Isolation</h2>
 * 
 * The JEE standards stipulate that each application in a web application
 * container should run with an isolated classloader. They further stipulate
 * that the class loading priority should (in most cases) be the reverse of what
 * is otherwise the standard for Java classloaders: The webapp classloader
 * attempts to load most classes itself, and only when it fails does it delegate
 * to its parent classloader.
 * 
 * This conventional setup will cause problems during testing if your test code
 * attempts to access objects created in the application, or vice versa. This is
 * because two classes that are loaded by different classloaders will be treated
 * as different, even if they were loaded from the exact same {@code .class}
 * file. On the other hand, weakening or eliminating classloader isolation may
 * cause problems if we attempt to run two applications that require different
 * library versions, or that are careless in their use of static variables.
 * 
 * To allow the user to manage these issues, this class provides several
 * strategies for managing classloader isolation. By default, no isolated
 * classloader is used: the application inside the container will see the same
 * classloader that the test context is using. Alternatively, you can choose
 * conventional webapp classloading, or an intermediate level of isolation
 * whereby an application classloader is used, but is given lower priority than
 * the parent classloader. Finally, the user may provide their own classloader.
 * 
 * <h2>Spring Context Inheritance<h2>
 * 
 * A conventional Spring web application runs in a Srping
 * {@code WebApplicationContext}. That context typically inherits from a root
 * {@code ApplicationContext}. Both contexts are configured in the deployment
 * descriptor (otherwise known as the {@code web.xml} file). The app server
 * creates the root {@code ApplicationContext} in response to an entry like
 * this:
 * 
 * <pre>
 * {@code 
 *  <context-param>
 *    <param-name>contextConfigLocation</param-name>
 *    <param-value>classpath:root-context.xml</param-value>
 *  </context-param>
 *    
 *  <!-- Creates the Spring Container shared by all Servlets and Filters -->
 *  <listener>
 *    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
 *  </listener>
 * }
 * </pre>
 * 
 * 
 * The app server then creates one or more {@code WebApplicationContext}s in
 * response to entries like this:
 * 
 * <pre>
 * {@code
 *  <servlet>
 *    <servlet-name>appServlet</servlet-name>
 *    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
 *    <init-param>
 *      <param-name>contextConfigLocation</param-name>
 *      <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
 *    </init-param>
 *    <load-on-startup>2</load-on-startup>
 *  </servlet>
 * }
 * </pre>
 * 
 * This state of affairs is not always ideal for testing, because one may wish
 * to have access to the embedded application's Spring context from the test
 * code context or vice versa. The {@code JettyWebApplication} will, by default,
 * create a root context that inherits from the external Spring context, instead
 * of the one created by {@code ContextLoaderListener}.
 * 
 * In cases where you are using the JettyWebApplication container to run a mock
 * service, you will probably have full freedom to write the web.xml however you
 * want. In these cases, you should simply omit the registration of the Spring
 * {@code ContextLoaderListener} (the first code snippet above). You may
 * continue to define the context parameter {@code contextConfigLocations}, in
 * which case the root context for the webapp will be configured from the
 * indicated location. It will still inherit from the test environment's Spring
 * container.
 * 
 * In other cases you may wish to use unmodified a web.xml that has been written
 * for deployment in a standard webapp container. For these situations, it would
 * be nice if the {@code JettyWebApplication} were written to search the context
 * configuration before running it, and were to remove any references to a
 * listener that implements {@code ContextLoaderListener} before registering its
 * own listener. That functionality has not yet been implemented.
 * 
 * If you wish to permit the standard handling of Spring contexts, you may
 * specify {@link #isUsingExternalSpringContext(false )}
 * 
 * <h2>Directory organization</h2>
 * 
 * Under the default (and recommended) configuration, the JettyWebApplication
 * will not run the loaded application with its own classloader. In this case,
 * you will have no control over where the classloader looks for files. It will
 * find them wherever the test environment's classloader finds them. Usually
 * that's what you want.
 * 
 * If, on the other hand, you are using Jetty's standard classloader management,
 * {@code JettyWebApplication} gives you properties for modifying how the
 * classloader finds resources: {@link #setWar}, {@link #setResourceBase}, and
 * {@link JettyWebApplication#setDescriptor}
 * 
 * If you have supplied your own classloader, then, for better or worse, you
 * have full control over how it resolves resources.
 * 
 * @author temp_dmenes
 * 
 */
public class JettyWebApplication extends BaseWebApplication
{
  private boolean               _serverInstancePerTest      = false;

  private ClassLoaderStrategy   _classLoaderStrategy        = ClassLoaderStrategy.NO_CLASSLOADER_ISOLATION;
  private ClassLoader           _applicationClassLoader     = null;

  private String                _contextPath                = null;
  private String                _descriptor                 = null;
  private String                _resourceBase               = null;
  private String                _war                        = null;
  private boolean               _extractWar                 = false;

  private ApplicationContext    _externalContext            = null;
  private WebApplicationContext _rootContext                = null;
  private boolean               _usingExternalSpringContext = false;

  private int                   _port                       = 8085;
  private String                _interface                  = "0.0.0.0";

  private Server                _server                     = null;
  private WebAppContext         _webApp                     = null;

  private Logger                _logger                     = LoggerFactory.getLogger (JettyWebApplication.class);

  public enum ClassLoaderStrategy {
    NO_CLASSLOADER_ISOLATION,
    JEE_CLASSLOADER_ISOLATION,
    GIVE_PARENT_CLASSLOADER_PRIORITY,
    USE_CUSTOM_CLASSLOADER
  }

  /**
   * If true, a new server instance will be initialized for each test. If false,
   * a single server instance will be used for all tests in the same Spring
   * context.
   * 
   * @return Current value
   */
  public boolean isServerInstancePerTest () {
    return _serverInstancePerTest;
  }

  /**
   * If true, a new server instance will be initialized for each test. If false,
   * a single server instance will be used for all tests in the same Spring
   * context.
   */
  public void setServerInstancePerTest (boolean serverInstancePerTest) {
    _serverInstancePerTest = serverInstancePerTest;
  }

  /**
   * Set the webapp context path.
   * 
   * This string will be prepended to all of the server URL paths when resolving
   * requests.
   * 
   * @return
   */
  public String getContextPath () {
    return _contextPath;
  }

  /**
   * Get the webapp context path.
   * 
   * This string will be prepended to all of the server URL paths when resolving
   * requests.
   * 
   * @param the
   *          value
   */
  public void setContextPath (String contextPath) {
    _contextPath = contextPath;
  }

  /**
   * Set the location of the web.xml file.
   * 
   * @return
   */
  public String getDescriptor () {
    return _descriptor;
  }

  /**
   * Get the location of the web.xml file in use.
   * 
   * @param descriptor
   */
  public void setDescriptor (String descriptor) {
    _descriptor = descriptor;
  }

  /**
   * Gets the base URL from which classpath resources will be resolved.
   * 
   * As this functionality is implemented by the classloader, this property is
   * ignored if the {@code classLoaderStrategy} is
   * {@code NO_CLASSLOADER_ISOLATION} or {@code USE_CUSTOM_CLASSLOADER}.
   * 
   * @return the base resource URL
   */
  public String getResourceBase () {
    if (_resourceBase != null) {
      return _resourceBase;
    }
    return ".";

    // if (!StringUtils.isEmpty (_descriptor)) {
    // try {
    // String descriptorUrl = getApplicationClassLoader ().getResource
    // (_descriptor).toString ();
    // String baseUrl = descriptorUrl;
    // if (descriptorUrl.endsWith (_descriptor)) {
    // baseUrl = descriptorUrl.substring (0, descriptorUrl.length () -
    // _descriptor.length ());
    // }
    // return baseUrl;
    // } catch (Exception e) {
    // // Do nothing--we will return null
    // }
    // }
    //
    // return null;
  }

  /**
   * Sets the base URL from which classpath resources will be resolved.
   * 
   * As this functionality is implemented by the classloader, this property is
   * ignored if the {@code classLoaderStrategy} is
   * {@code NO_CLASSLOADER_ISOLATION} or {@code USE_CUSTOM_CLASSLOADER}.
   */
  public void setResourceBase (String resourceBase) {
    _resourceBase = resourceBase;
  }

  /**
   * Gets the location of a "war" file containing the web application
   * 
   * Depending on the setting of the {@code extractWar} property, this may be
   * the location of a compressed war archive, or of a directory.
   * 
   * It is usually unnecessary to set both this property and the
   * {@code resourceBase} property.
   * 
   * As this functionality is implemented by the classloader, this property is
   * ignored if the {@code classLoaderStrategy} is
   * {@code NO_CLASSLOADER_ISOLATION} or {@code USE_CUSTOM_CLASSLOADER}.
   * 
   * @return the war file location
   */
  public String getWar () {
    return _war;
  }

  /**
   * Sets the location of a "war" file containing the web application
   * 
   * Depending on the setting of the {@code extractWar} property, this may be
   * the location of a compressed war archive, or of a directory.
   * 
   * It is usually unnecessary to set both this property and the
   * {@code resourceBase} property.
   * 
   * As this functionality is implemented by the classloader, this property is
   * ignored if the {@code classLoaderStrategy} is
   * {@code NO_CLASSLOADER_ISOLATION} or {@code USE_CUSTOM_CLASSLOADER}.
   */
  public void setWar (String war) {
    _war = war;
  }

  /**
   * If true, the {@code war} property is a compressed archive. If false, it is
   * a directory.
   * 
   * @return The current value
   */
  public boolean isExtractWar () {
    return _extractWar;
  }

  /**
   * If true, the {@code war} property is a compressed archive. If false, it is
   * a directory.
   */
  public void setExtractWar (boolean extractWar) {
    _extractWar = extractWar;
  }

  /**
   * The context that will serve as the parent of the root Spring
   * {@code WebApplicationContext}
   * 
   * @return The current value
   */
  public ApplicationContext getExternalContext () {
    return _externalContext;
  }

  /**
   * The context that will serve as the parent of the root Spring
   * {@code WebApplicationContext}
   * 
   * This field is declared {@code @Autowired}. When this
   * {@code JettyWebApplication} object is created by Spring, as intended, this
   * field will default to the Spring context in which it is created.
   */
  @Autowired
  public void setExternalContext (ApplicationContext externalContext) {
    _externalContext = externalContext;
  }

  /**
   * The actual root {@code WebApplicationContext} that will be wired into the
   * container.
   * 
   * If {@code usingExernalSpringContext} is false, this will be null.
   * 
   * @return the context.
   */
  public WebApplicationContext getRootContext () {
    return _rootContext;
  }

  /**
   * If true, inject a root Spring {@code WebApplicationContext} into the
   * container which inherits from the context specified in the
   * {@code externalContext} property. Ordinarily, this will be the Spring
   * context in which the {@code JettyWebApplication} object was created.
   * 
   * @return The current value
   */
  public boolean isUsingExternalSpringContext () {
    return _usingExternalSpringContext;
  }

  /**
   * If true, inject a root Spring {@code WebApplicationContext} into the
   * container which inherits from the context specified in the
   * {@code externalContext} property. Ordinarily, this will be the Spring
   * context in which the {@code JettyWebApplication} object was created.
   */
  public void setUsingExternalSpringContext (boolean usingExternalSpringContext) {
    _usingExternalSpringContext = usingExternalSpringContext;
  }

  /**
   * Strategy used for isolating class loading for the contained application
   * 
   * @return the current setting
   */
  public ClassLoaderStrategy getClassLoaderStrategy () {
    return _classLoaderStrategy;
  }

  /**
   * Strategy used for isolating class loading for the contained application
   */
  public void setClassLoaderStrategy (ClassLoaderStrategy classLoaderStrategy) {
    _classLoaderStrategy = classLoaderStrategy;
  }

  public ClassLoader getApplicationClassLoader () {
    return _applicationClassLoader;
  }

  /**
   * A custom classloader to use for the web application.
   * 
   * Ignored unless the {@code classLoaderStrategy} is
   * {@code USE_CUSTOM_CLASSLOADER}
   * 
   * @return the current setting
   */
  public void setApplicationClassLoader (ClassLoader applicationClassLoader) {
    _applicationClassLoader = applicationClassLoader;
  }

  /**
   * IP port on which the application will listen for connections.
   * 
   * @return the current value.
   */
  public int getPort () {
    return _port;
  }

  /**
   * IP port on which the application will listen for connections.
   * 
   * Defaults to 8085
   */
  public void setPort (int port) {
    _port = port;
  }

  /**
   * IP address of network adapter interface on which the application will
   * listen for connections.
   * 
   * @return the current value
   */
  public String getInterface () {
    return _interface;
  }

  /**
   * IP address of network adapter interface on which the application will
   * listen for connections.
   * 
   * Defaults to all interfaces (0.0.0.0)
   */
  public void setInterface (String _interface) {
    this._interface = _interface;
  }

  @Override
  public void startupBeforeDependencies () throws Exception {
    super.startupBeforeDependencies ();
    initServer ();
  }

  @Override
  public void afterTestBeforeDependencies () throws Exception {
  }

  @Override
  public void afterTestAfterDependencies () throws Exception {
    if (_serverInstancePerTest) {
      shutdownServer ();
    }
    super.afterTestAfterDependencies ();
  }

  @Override
  public void betweenTestsBeforeDependencies () throws Exception {
    if (_serverInstancePerTest) {
      initServer ();
    }
    super.betweenTestsBeforeDependencies ();
  }

  @Override
  public void shutdownAfterDependencies () throws Exception {
    shutdownServer ();
    super.shutdownAfterDependencies ();
  };

  private void initServer () throws Exception {
    _server = new Server (new InetSocketAddress (getInterface (), getPort ()));

    _webApp = new WebAppContextWithLoadConfigurations ();

    _server.setHandler (_webApp);

    configureClassLoader ();

    // We want to load the default Jetty WebAppContext configuration classes,
    // and then add our own that will configure our Spring context.
    if (isUsingExternalSpringContext ()) {
      ((WebAppContextWithLoadConfigurations) _webApp).loadConfigurations ();
      final List<Configuration> configs = new ArrayList<Configuration> (Arrays.asList (_webApp.getConfigurations ()));
      configs.add (new JettySpringContextConfigurer (getExternalContext (), getApplicationClassLoader ()));
      _webApp.setConfigurations (configs.toArray (new Configuration[configs.size ()]));
    }
    configureDescriptor ();
    _server.start ();

  }

  private void shutdownServer () throws Exception {
    try {
      _server.stop ();
      _server.join ();
    } catch (Exception e) {
      // Repeated calls may happen in some circumstances. Just swallow any errors.
    }
  }

  private void configureClassLoader () throws IOException {
    switch (_classLoaderStrategy) {

    case JEE_CLASSLOADER_ISOLATION:
      setApplicationClassLoader (new WebAppClassLoader (_webApp));
      _webApp.setParentLoaderPriority (false);
      break;

    case GIVE_PARENT_CLASSLOADER_PRIORITY:
      setApplicationClassLoader (new WebAppClassLoader (_webApp));
      _webApp.setParentLoaderPriority (true);
      break;

    case USE_CUSTOM_CLASSLOADER:
      break;

    case NO_CLASSLOADER_ISOLATION:
      setApplicationClassLoader (JettyWebApplication.class.getClassLoader ());
      break;
    }

    _webApp.setClassLoader (getApplicationClassLoader ());
  }

  private void configureDescriptor () {
    final String descriptorUrl = getApplicationClassLoader ().getResource (getDescriptor ()).toString ();
    _logger.debug ("Configuring web app from file at {}", descriptorUrl);
    _webApp.setDescriptor (descriptorUrl);
    _webApp.setContextPath (getContextPath ());
    if (getWar () != null) {
      _webApp.setWar (getWar ());
    }
    if (getResourceBase () != null) {
      _webApp.setResourceBase (getResourceBase ());
    }
  }

  // Get access to the protected LoadConfigurations method
  private class WebAppContextWithLoadConfigurations extends WebAppContext
  {
    @Override
    public void loadConfigurations () throws Exception {
      super.loadConfigurations ();
    }
  }

}
