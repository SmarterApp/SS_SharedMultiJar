/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.unittest.db;

import static org.opentestsystem.shared.test.api.DataCorruptionWatcher.Tester.isDataCorrupt;

import java.io.FileNotFoundException;
import java.net.URL;
import java.util.Map;

import javax.sql.DataSource;

import org.apache.commons.lang3.StringUtils;
import org.dbunit.database.DatabaseConfig;
import org.dbunit.database.DatabaseDataSourceConnection;
import org.dbunit.database.IDatabaseConnection;
import org.dbunit.dataset.IDataSet;
import org.dbunit.dataset.ReplacementDataSet;
import org.dbunit.dataset.xml.FlatXmlDataSetBuilder;
import org.dbunit.ext.mysql.MySqlDataTypeFactory;
import org.dbunit.operation.DatabaseOperation;
import org.opentestsystem.shared.test.api.DBDataCorruptionReporter;
import org.opentestsystem.shared.test.api.DBDataDeployment;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

public class DBDataDeployerImpl implements DBDataDeployment
{

  private static Logger              logger              = LoggerFactory.getLogger (DBDataDeployerImpl.class);

  private Boolean                    enabled             = true;
  private DataSource                 dataSource;
  private String                     dataDefinitionName;
  private String                     importFileName      = null;
  private URL                        xmlFile             = null;
  private Map<String, String>        dataReplacementsMap = null;
  private DBDataCorruptionReporter[] corruptionReporters;

  public boolean isEnabled () {
    return enabled;
  }

  public void setEnabled (boolean value) {
    enabled = value;
  }

  public Map<String, String> getDataReplacementsMap () {
    return dataReplacementsMap;
  }

  public void setDataReplacementsMap (Map<String, String> dataReplacementsMap) {
    this.dataReplacementsMap = dataReplacementsMap;
  }

  public void setImportFileName (String importFileName) {
    this.importFileName = importFileName;
  }

  public void setDataDefinitionName (String dataDefinitionName) {
    this.dataDefinitionName = dataDefinitionName;
  }

  public void setDataSource (DataSource dataSource) {
    this.dataSource = dataSource;
  }

  @Override
  public void startupBeforeDependencies () throws Exception {
    // Populate all tables from xml file
    // If filename is empty or not given, throw error
    if (!enabled) {
      return;
    }
    if (StringUtils.isBlank (importFileName) || StringUtils.isBlank (dataDefinitionName)) {
      throw new FileNotFoundException ("Cannot load test data because file name or data definition name have not been specified.");
    }
    final String resourceName = new StringBuilder ("import/")
        .append (dataDefinitionName)
        .append ('/')
        .append (importFileName).toString ();

    xmlFile = DBDataDeployerImpl.class.getClassLoader ().getResource (resourceName);
    if (xmlFile == null) {
      throw new FileNotFoundException (String.format ("Cannot load test data; cannot find file %s", resourceName));
    }
    insertData (xmlFile);
  }

  @Override
  @Autowired (required = false)
  public void setDataCorruptionReporters (DBDataCorruptionReporter[] reporter) {
    this.corruptionReporters = reporter;
  }

  private void insertData (URL fileUrl) throws Exception {
    IDatabaseConnection dbUnitCon = new DatabaseDataSourceConnection (this.dataSource);

    final DatabaseConfig config = dbUnitCon.getConfig ();
    config.setProperty (DatabaseConfig.PROPERTY_ESCAPE_PATTERN, "`?`");
    config.setProperty ("http://www.dbunit.org/properties/datatypeFactory", new MySqlDataTypeFactory ());
    FlatXmlDataSetBuilder builder = new FlatXmlDataSetBuilder ();
    builder.setColumnSensing (true);
    IDataSet dataSet = builder.build (fileUrl.openStream ());
    try {
      ReplacementDataSet rDataSet = new ReplacementDataSet (dataSet);
      if (dataReplacementsMap != null) {
        for (String key : dataReplacementsMap.keySet ()) {
          rDataSet.addReplacementObject ("${" + key + "}", dataReplacementsMap.get (key));
        }
      }
      DatabaseOperation.CLEAN_INSERT.execute (dbUnitCon, rDataSet);
    } finally {
      dbUnitCon.close ();
    }

  }

  @Override
  public void startupAfterDependencies () throws Exception {
    // Nothing to be done
  }

  @Override
  public void betweenTestsBeforeDependencies () throws Exception {
    if (enabled && isDataCorrupt (corruptionReporters)) {
      // Reload all data from xml file
      logger.info ("Test data could not be rolled back. Reloading dataset {}", dataDefinitionName);
      insertData (xmlFile);
    }
  }

  @Override
  public void betweenTestsAfterDependencies () throws Exception {
    // Nothing in this version
  }

  @Override
  public void shutdownBeforeDependencies () throws Exception {
    // Nothing to be done
  }

  @Override
  public void shutdownAfterDependencies () throws Exception {
    // Nothing to be done
  }

  @Override
  public void afterTestBeforeDependencies () throws Exception {
    // Nothing to be done
  }

  @Override
  public void afterTestAfterDependencies () throws Exception {
    // Nothing to be done
  }

}
