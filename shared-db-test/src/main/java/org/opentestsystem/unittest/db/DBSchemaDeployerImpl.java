/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.unittest.db;

import static org.opentestsystem.shared.test.api.DataCorruptionWatcher.Tester.isDataCorrupt;

import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.Properties;

import javax.sql.DataSource;

import org.opentestsystem.shared.test.api.DBDataCorruptionReporter;
import org.opentestsystem.shared.test.api.DBSchemaDeployment;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import com.mchange.v2.c3p0.DataSources;

public class DBSchemaDeployerImpl implements DBSchemaDeployment
{
  /**
   * "Data Source" at which we can throw "CREATE DATABASE" calls
   */
  private static final Logger        _logger    = LoggerFactory.getLogger (DBSchemaDeployerImpl.class);

  /**
   * A delay (in milliseconds) to wait after making structural changes to give
   * MYSQL time to execute them
   */
  public static final long           DDL_DELAY  = 1000;

  private Boolean                    enabled    = true;

  private Properties                 masterDataSourceProperties;

  private String                     schemaDefinitionName;
  private String                     dbDialect;
  private String                     dbName;
  private String                     additionalUrlParm;
  private String                     dbUrl;

  private DataSource                 masterDataSource;

  private boolean                    keepSchema = false;
  private DBDataCorruptionReporter[] corruptionReporters;

  private DataSource                 childDataSource;

  public boolean isEnabled () {
    return enabled;
  }

  public void setEnabled (boolean value) {
    enabled = value;
  }

  public boolean getKeepSchema () {
    return keepSchema;
  }

  public void setKeepSchema (boolean keepSchema) {
    this.keepSchema = keepSchema;
  }

  public Properties getMasterDataSourceProperties () {
    return masterDataSourceProperties;
  }

  public void setMasterDataSourceProperties (Properties masterDataSourceProperties) {
    this.masterDataSourceProperties = masterDataSourceProperties;
  }

  public String getAdditionalUrlParm () {
    return additionalUrlParm;
  }

  public void setAdditionalUrlParm (String additionalUrlParm) {
    this.additionalUrlParm = additionalUrlParm;
  }

  public String getDbDialect () {
    return dbDialect;
  }

  public void setDbDialect (String dbDialect) {
    this.dbDialect = dbDialect;
  }

  public String getDbName () {
    return dbName;
  }

  public void setDbName (String dbName) {
    this.dbName = dbName;
  }

  public String getSchemaDefinitionName () {
    return schemaDefinitionName;
  }

  public void setSchemaDefinitionName (String schemaDefinitionName) {
    this.schemaDefinitionName = schemaDefinitionName;
  }

  @Override
  public void startupBeforeDependencies () throws Exception {

    if ( enabled ) {
      initMasterDataSource ();
      createDatabase ();
      Thread.sleep (DDL_DELAY);
      // at this point masterDataSource is not needed anymore;
      // we used it only to createDatabase, we can dropDatabase on
      // connection from childDataSource.
      closeMasterDataSource ();
    }

    initChildDataSource ();

    if ( enabled ) {
      try (Connection connection = childDataSource.getConnection ()) {
        connection.setAutoCommit (false);
        createTables (connection);
        Thread.sleep (DDL_DELAY);
      }
    }

    // We return control to the framework here so that data can be injected into
    // the tables
  }

  @Override
  public void startupAfterDependencies () throws Exception {
    // Once we get here, data have been injected into the tables
    if (enabled) {
      try (Connection connection = childDataSource.getConnection ()) {
        connection.setAutoCommit (false);
        createConstraints (connection);
        connection.commit ();
        Thread.sleep (DDL_DELAY);
        createIndices (connection);
        connection.commit ();
        Thread.sleep (DDL_DELAY);
      }
    }
  }

  @Override
  public void betweenTestsBeforeDependencies () throws Exception {
    if (enabled && isDataCorrupt (corruptionReporters)) {
      try (Connection connection = childDataSource.getConnection ()) {
        connection.setAutoCommit (false);
        dropConstraints (connection);
        connection.commit ();
        Thread.sleep (DDL_DELAY);
      }
    }
  }

  @Override
  public void betweenTestsAfterDependencies () throws Exception {
    if (enabled && isDataCorrupt (corruptionReporters)) {
      try (Connection connection = childDataSource.getConnection ()) {
        connection.setAutoCommit (false);
        createConstraints (connection);
        connection.commit ();
        Thread.sleep (DDL_DELAY);
      }
    }
  }

  @Override
  public void shutdownBeforeDependencies () throws Exception {
    if (enabled && !keepSchema) {
      try (Connection connection = childDataSource.getConnection ()) {
        connection.setAutoCommit (false);
        dropConstraints (connection);
        connection.commit ();
        Thread.sleep (DDL_DELAY);
      }
    }
  }

  @Override
  public void shutdownAfterDependencies () throws Exception {
    if (enabled && !keepSchema) {
      try (Connection connection = childDataSource.getConnection ()) {
        connection.setAutoCommit (false);
        dropTables (connection);
        connection.commit ();
        Thread.sleep (DDL_DELAY);
        dropDatabase (connection);
        connection.commit ();
        Thread.sleep (DDL_DELAY);
      }
    }
  }

  @Override
  @Autowired (required = false)
  public void setDataCorruptionReporters (DBDataCorruptionReporter[] reporters) {
    this.corruptionReporters = reporters;
  }

  private void initMasterDataSource () throws Exception {

    // masterDataSource = new ComboPooledDataSource ();
    // masterDataSource.setUser (masterDataSourceProperties.getProperty
    // ("user"));
    // masterDataSource.setPassword (masterDataSourceProperties.getProperty
    // ("password"));
    // masterDataSource.setJdbcUrl (masterDataSourceProperties.getProperty
    // ("jdbcUrl"));
    masterDataSource = DataSources.unpooledDataSource (masterDataSourceProperties.getProperty ("jdbcUrl"), masterDataSourceProperties);
    // try {
    // masterDataSource.setDriverClass (masterDataSourceProperties.getProperty
    // ("driverClass"));
    // } catch (PropertyVetoException e) {
    // _logger.error (String.format ("Can't setup driverClass:  %s",
    // e.getMessage ()));
    // throw new Exception (e.getMessage (), e);
    // }
    // The below statement does not work.
    // Meaning: trying to get connection from dataSource
    // created with it, causes exception.
    // masterDataSource.setProperties (masterDataSourceProperties);
  }

  private void closeMasterDataSource () {
    // No close method required (or permitted) on unpooled data sources.
    // masterDataSource.close ();
  }

  public void createDatabase () throws Exception {
    String cmd0 = new StringBuilder ("drop database if exists ").append (dbName).toString ();
    String cmd = new StringBuilder ("create database if not exists ").append (dbName).append (" default charset = UTF8;").toString ();
    _logger.debug ("Creating database {}", dbName);
    _logger.debug (masterDataSource.toString ());
    try (Connection mConnection = masterDataSource.getConnection ()) {
      mConnection.setAutoCommit (false);
      mConnection.createStatement ().execute (cmd0);
      mConnection.commit ();
      Thread.sleep (DDL_DELAY);
      mConnection.createStatement ().execute (cmd);
      mConnection.commit ();
      createDropIndexIfExistsProcedure (mConnection);
    }
  }

  private void createDropIndexIfExistsProcedure (Connection conn) throws Exception {
    String cmd0 = new StringBuilder ("use ").append (dbName).toString ();
    conn.createStatement ().execute (cmd0);

    String cmd = new StringBuilder
        ("CREATE PROCEDURE drop_index_if_exists(in theTable varchar(128), in theIndexName varchar(128) )\n")
            .append ("BEGIN\n")
            .append ("IF((SELECT COUNT(*) AS index_exists FROM information_schema.statistics WHERE TABLE_SCHEMA = DATABASE() and table_name =\n")
            .append ("theTable AND index_name = theIndexName) > 0) THEN\n")
            .append (" SET @s = CONCAT('DROP INDEX ' , theIndexName , ' ON ' , theTable);\n")
            .append (" PREPARE stmt FROM @s;\n")
            .append ("  EXECUTE stmt;\n")
            .append (" END IF;\n")
            .append ("END;\n").toString ();
    conn.createStatement ().execute (cmd);
  }

  public void dropDatabase (Connection connection) throws Exception {
    String cmd = new StringBuilder ("drop database if exists ").append (dbName).toString ();
    connection.createStatement ().execute (cmd);
  }

  public String getDatabaseURL () {
    // TODO: Return the URL of the databse created and managed by this object
    return dbUrl;
  }

  private void initChildDataSource () throws Exception {
    String url = masterDataSourceProperties.getProperty ("jdbcUrl");
    dbUrl = new StringBuilder (url).append ("/").append (dbName).append (additionalUrlParm).toString ();
    ComboPooledDataSource cpds = new ComboPooledDataSource ();
    cpds.setJdbcUrl (dbUrl);
    cpds.setProperties (masterDataSourceProperties);
    childDataSource = cpds;
  }

  private void dropConstraints (Connection connection) throws IOException, SQLException {
    runScript (connection, "drop_constraints.sql");
  }

  private void dropTables (Connection connection) throws IOException, SQLException {
    runScript (connection, "drop_tables.sql");
  }

  private void createConstraints (Connection connection) throws IOException, SQLException {
    runScript (connection, "create_constraints.sql");
  }

  private void createTables (Connection connection) throws IOException, SQLException {
    runScript (connection, "create_tables.sql");
  }

  private void createIndices (Connection connection) throws IOException, SQLException {
    runScript (connection, "create_indices.sql");
  }

  private void runScript (Connection connection, String scriptName) throws IOException, SQLException {
    String resourceName = new StringBuilder ("sql/")
        .append (dbDialect).append ('/')
        .append (schemaDefinitionName).append ('/')
        .append (scriptName)
        .toString ();

    SqlScriptExecutor.execScript (resourceName, connection);
  }

  @Override
  public Connection getConnection () throws SQLException {
    return childDataSource.getConnection ();
  }

  @Override
  public Connection getConnection (String username, String password)
      throws SQLException {
    return childDataSource.getConnection (username, password);
  }

  @Override
  public PrintWriter getLogWriter () throws SQLException {
    return childDataSource.getLogWriter ();
  }

  @Override
  public void setLogWriter (PrintWriter out) throws SQLException {
    childDataSource.setLogWriter (out);
  }

  @Override
  public void setLoginTimeout (int seconds) throws SQLException {
    childDataSource.setLoginTimeout (seconds);
  }

  @Override
  public int getLoginTimeout () throws SQLException {
    return childDataSource.getLoginTimeout ();
  }

  @Override
  public java.util.logging.Logger getParentLogger ()
      throws SQLFeatureNotSupportedException {
    // return childDataSource.getParentLogger ();
    throw new SQLFeatureNotSupportedException ();
  }

  @Override
  public <T> T unwrap (Class<T> iface) throws SQLException {
    return null;
  }

  @Override
  public boolean isWrapperFor (Class<?> iface) throws SQLException {
    return false;
  }

  @Override
  public void afterTestBeforeDependencies () throws Exception {
  }

  @Override
  public void afterTestAfterDependencies () throws Exception {
  }

}
