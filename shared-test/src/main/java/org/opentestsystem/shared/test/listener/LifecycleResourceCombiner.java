/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.test.listener;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.shared.test.api.LifecycleResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.PropertyValue;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.context.ApplicationContext;

/**
 * Class to find all of the beans in a Spring context that implement
 * LifecycleResource, and return them in an array that is sorted so that no
 * element comes before its dependencies.
 * 
 * @author temp_dmenes
 * 
 */
public class LifecycleResourceCombiner implements LifecycleResource
{

  private static final Logger _logger = LoggerFactory.getLogger(LifecycleResourceCombiner.class);
  private ApplicationContext  _applicationContext = null;
  private LifecycleResource[] _lifecycleResources = null;

  public ApplicationContext getApplicationContext () {
    return _applicationContext;
  }

  public void setApplicationContext (ApplicationContext applicationContext) {
    _applicationContext = applicationContext;
  }

  @Override
  public void startupBeforeDependencies () throws Exception {
    _lifecycleResources = getSortedResources ();
    for (LifecycleResource resource_i : _lifecycleResources) {
      resource_i.startupBeforeDependencies ();
    }
  }

  @Override
  public void startupAfterDependencies () throws Exception {
    for (int i = _lifecycleResources.length - 1; i >= 0; i--) {
      _lifecycleResources[i].startupAfterDependencies ();
    }
  }

  @Override
  public void betweenTestsBeforeDependencies () throws Exception {
    for (LifecycleResource resource_i : _lifecycleResources) {
      resource_i.betweenTestsBeforeDependencies ();
    }
  }

  @Override
  public void betweenTestsAfterDependencies () throws Exception {
    for (int i = _lifecycleResources.length - 1; i >= 0; i--) {
      _lifecycleResources[i].betweenTestsAfterDependencies ();
    }
  }

  @Override
  public void afterTestBeforeDependencies () throws Exception {
    for (LifecycleResource resource_i : _lifecycleResources) {
      resource_i.afterTestBeforeDependencies ();
    }
  }

  @Override
  public void afterTestAfterDependencies () throws Exception {
    for (int i = _lifecycleResources.length - 1; i >= 0; i--) {
      _lifecycleResources[i].afterTestAfterDependencies ();
    }
  }

  @Override
  public void shutdownBeforeDependencies () throws Exception {
    for (LifecycleResource resource_i : _lifecycleResources) {
      resource_i.shutdownBeforeDependencies ();
    }
  }

  @Override
  public void shutdownAfterDependencies () throws Exception {
    for (int i = _lifecycleResources.length - 1; i >= 0; i--) {
      _lifecycleResources[i].shutdownAfterDependencies ();
    }
  }

  private LifecycleResource[] getSortedResources () {
    // Build a doubly-linked tree of all Spring dependencies.
    final ApplicationContext context = getApplicationContext ();
    final BeanDefinitionRegistry registry = (BeanDefinitionRegistry) context;
    final Map<String, BeanHolder> beanHolderMap = new HashMap<String, BeanHolder> ();

    for (String key_i : registry.getBeanDefinitionNames ()) {
      final BeanDefinition definition_i = registry.getBeanDefinition (key_i);

      // Make sure that there is a holder for this bean in the map.
      // The holder may exist already if this bean's name has appeared as a
      // dependency for another bean.
      BeanHolder beanHolder = beanHolderMap.get (key_i);
      if (beanHolder == null) {
        beanHolder = new BeanHolder (key_i);
        beanHolderMap.put (key_i, beanHolder);
      }
      beanHolder.bean = context.getBean (key_i);

      // Add the constructor arguments as antecedents
      BeanHolder antecedentHolder = null;
      String antecedentBeanName = null;
      for (final ValueHolder value_j : definition_i.getConstructorArgumentValues ().getGenericArgumentValues ()) {
        final Object antecedentValue = value_j.getValue ();
        if (antecedentValue instanceof RuntimeBeanReference) {
          antecedentBeanName = ((RuntimeBeanReference) antecedentValue).getBeanName ();
          antecedentHolder = beanHolderMap.get (antecedentBeanName);
          if (antecedentHolder == null) {
            antecedentHolder = new BeanHolder (antecedentBeanName);
            beanHolderMap.put (antecedentBeanName, antecedentHolder);
          }
          beanHolder.beansIDependOn.add (antecedentHolder);
          antecedentHolder.beansWhoDependOnMe.add (beanHolder);
        }
      }
      
      // Add any factory bean as antecedent
      antecedentBeanName = definition_i.getFactoryBeanName ();
      if ( ! StringUtils.isBlank (antecedentBeanName)) {
        antecedentHolder = beanHolderMap.get (antecedentBeanName);
        if (antecedentHolder == null) {
          antecedentHolder = new BeanHolder (antecedentBeanName);
          beanHolderMap.put (antecedentBeanName, antecedentHolder);
        }
        beanHolder.beansIDependOn.add (antecedentHolder);
        antecedentHolder.beansWhoDependOnMe.add (beanHolder);
      }
      

      // Add the properties as antecedents
      if (definition_i.getPropertyValues () != null && definition_i.getPropertyValues ().getPropertyValueList () != null) {
        for (final PropertyValue value_j : definition_i.getPropertyValues ().getPropertyValueList ()) {
          final Object antecedentValue = value_j.getValue ();
          if (antecedentValue instanceof RuntimeBeanReference) {
            antecedentBeanName = ((RuntimeBeanReference) antecedentValue).getBeanName ();
            antecedentHolder = beanHolderMap.get (antecedentBeanName);
            if (antecedentHolder == null) {
              antecedentHolder = new BeanHolder (antecedentBeanName);
              beanHolderMap.put (antecedentBeanName, antecedentHolder);
            }
            beanHolder.beansIDependOn.add (antecedentHolder);
            antecedentHolder.beansWhoDependOnMe.add (beanHolder);
          }
        }
      }

      // Add explicitly identified antecedents
      if (definition_i.getDependsOn () != null) {
        for (String name_j : definition_i.getDependsOn ()) {
          antecedentBeanName = name_j;
          antecedentHolder = beanHolderMap.get (antecedentBeanName);
          if (antecedentHolder == null) {
            antecedentHolder = new BeanHolder (antecedentBeanName);
            beanHolderMap.put (antecedentBeanName, antecedentHolder);
          }
          beanHolder.beansIDependOn.add (antecedentHolder);
          antecedentHolder.beansWhoDependOnMe.add (beanHolder);
        }
      }
    }

    // Prune the tree of all items that aren't LifecycleResource
    // This step is easier with a stable ordering, so we copy things into a
    // list.
    List<BeanHolder> beanHolderList = new ArrayList<BeanHolder> (beanHolderMap.values ());
    int i = 0;
    while (i < beanHolderList.size ()) {
      final BeanHolder beanHolder_i = beanHolderList.get (i);
      if (beanHolder_i.bean instanceof LifecycleResource) {
        i++;
      }
      else {
        for (final BeanHolder antecedent_j : beanHolder_i.beansIDependOn) {
          for (final BeanHolder dependent_k : beanHolder_i.beansWhoDependOnMe) {
            dependent_k.beansIDependOn.add (antecedent_j);
            antecedent_j.beansWhoDependOnMe.add (dependent_k);
          }
          antecedent_j.beansWhoDependOnMe.remove (beanHolder_i);
        }
        for (final BeanHolder dependent_j : beanHolder_i.beansWhoDependOnMe) {
          dependent_j.beansIDependOn.remove (beanHolder_i);
        }
        beanHolderList.remove (i);
      }
    }

    // Now do the topo sort.
    //
    // We cycle through the list repeatedly. Each time, we can pull out anyone
    // who doesn't have a dependency on anyone else who is still in the list.
    // This leads to everyone being pulled out before their dependencies.
    //
    // If at the end we still have people in the list who depend on each
    // other, we have a dependency cycle.

    i = 0;
    boolean found = true;
    int n = beanHolderList.size ();
    LifecycleResource[] ans = new LifecycleResource[n];
    StringBuilder message = new StringBuilder("Resolved sequence of LifecycleResource elements in Spring context:\r\n  ");
    while (i < n) {
      if (!found) {
        // We got all the way through the list without finding any with no
        // antecedents. There is a cycle
        StringBuilder beanNames = new StringBuilder ();
        for ( BeanHolder beanHolder_k : beanHolderList ) {
          beanNames.append (beanHolder_k.beanName).append (" depends on ( ");
          for ( BeanHolder beanHolder_l : beanHolder_k.beansIDependOn) {
            beanNames.append( beanHolder_l.beanName).append(" ");
          }
          beanNames.append(")\r\n");
        }
        throw new RuntimeException ( String.format( "LifecycleResource beans have one or more reference cycles involving:\r\n   %s", beanNames) );
      }
      found = false;
      int j = 0;
      while (j < beanHolderList.size ()) {
        final BeanHolder beanHolder_j = beanHolderList.get (j);
        if (beanHolder_j.beansIDependOn.size () == 0) {
          ans[i] = (LifecycleResource) beanHolder_j.bean;
          i++;
          found = true;
          beanHolderList.remove (j);
          for (final BeanHolder beanHolder_k : beanHolder_j.beansWhoDependOnMe) {
            beanHolder_k.beansIDependOn.remove (beanHolder_j);
          }
          message.append (beanHolder_j.beanName).append (" ");
        }
        else {
          j++;
        }
      }
    }
    _logger.info( message.toString() );
    return ans;
  }

  private static class BeanHolder
  {
    public Object                bean               = null;
    public final Set<BeanHolder> beansIDependOn     = new HashSet<BeanHolder> ();
    public final Set<BeanHolder> beansWhoDependOnMe = new HashSet<BeanHolder> ();
    public final String beanName;
    
    public BeanHolder( String beanName) {
      this.beanName = beanName;
    }
  }
}
